package NowCoder;
import java.util.Scanner;

/*	[编程题]合唱团

	有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，
	要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？
	
	
	输入描述:
		每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 <= n <= 50)，
		表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 <= ai <= 50）。
		接下来的一行包含两个整数，k 和 d (1 <= k <= 10, 1 <= d <= 50)。


	输出描述:
		输出一行表示最大的乘积。
		
		
	示例1
	    输入

		3
		7 4 7
		2 50
	   输出

		49
		
*/

public class DynamicPlanningSelecting {
    public static void main(String[] args){        
        Scanner in = new Scanner(System.in);        
        while (in.hasNextInt()){
            int n = in.nextInt();
            int[] arr = new int[n+1];
            for(int i = 1;i<=n;i++){
                arr[i] = in.nextInt();
            }
            int K = in.nextInt();
            int d = in.nextInt();  
            
            // fmax[k][i]表示 : 当选中了k个学生，并且以第i个学生为结尾，所产生的最大乘积；
            // fmin[k][i]表示 : 当选中了k个学生，并且以第i个学生为结尾，所产生的最小乘积；
            
            
            //初始化第一行
            long[][] fmax = new long[K+1][n+1];
            long[][] fmin = new long[K+1][n+1];            
            long res = Integer.MIN_VALUE;  // 记得用Long类型，考虑数值范围            
            
            for(int i = 1; i<=n; i++){  //学生在原来的数组中的位置索引i，原始数组共n个元素
            	
                fmax[1][i] = arr[i];   // 记录最大乘积
                fmin[1][i] = arr[i];   // 记录最小乘积 

                for(int k = 2; k <= K; k++){ //从选择第1个学生，到第K个学生，总共要选取K个学生，k的索引为第k个学生
                	
                    for(int j = i - 1; j > 0 && i - j <= d ; j--){  //比较相邻两个学生之间的距离从1到d，j的索引为下一个学生
                    	
                        fmax[k][i] = Math.max(fmax[k][i], Math.max(fmax[k-1][j]*arr[i],fmin[k-1][j]*arr[i]));
                        fmin[k][i] = Math.min(fmin[k][i], Math.min(fmax[k-1][j]*arr[i],fmin[k-1][j]*arr[i]));
                        System.out.println(fmax[k]);
                        System.out.println(fmin[k]);
                    }
                }
                res = Math.max(res,fmax[K][i]);
            }
            System.out.println(res);
        }
        in.close();
    }    
}

/*
解题思路：

先修知识：

动态规划： 动态规划表面上很难，其实存在很简单的套路：当求解的问题满足以下两个条件时， 就应该使用动态规划： 
主问题的答案 包含了 可分解的子问题答案 （也就是说，问题可以被递归的思想求解）
递归求解时， 很多子问题的答案会被多次重复利用
动态规划的本质思想就是递归， 但如果直接应用递归方法， 子问题的答案会被重复计算产生浪费， 同时递归更加耗费栈内存， 所以通常用一个二维矩阵（表格）来表示不同子问题的答案， 以实现更加高效的求解。
题目难点：

元素有正有负
如何满足相邻元素的距离不超过d 的限制
巧妙地分解问题

给定n个元素， 寻找k 个元素使乘积最大，可以从这k 个元素中最后一个元素所在的位置入手来思考。

例如： 对于数组 a=【7，4，7】， 假如k=2, d=2. 当我们假设 a[2] 为最后一个元素时， 还需要在a[2] 之前的元素中，寻找到一个长度为 k-1 的乘积序列， 且该序列的最后一个元素a[ｐ] 与a[2]的距离小于等于d ： 2-ｐ <=d

此时问题转化成了多个子问题：当我们以所有满足条件的a[ｐ] （这里p可以取0和1） 作为最后一个元素时， 能获得的长度为 k-1 的最大乘积序列的值是多少. 这里由于k-1==1， 答案分别是 7 和 4.

得到子问题的解后，挑选其中最大的一个（这里是7） 与a[2]（同样是7） 相乘， 求出以a[2] 位最后一个元素时， 能获得的最大乘积序列的值是49

以上分析中用到的例子都是正值， 当有负值时， 我们只需要额外计算， 当以a[i]为最后一个元素时，能获得的乘积序列的最小值是多少， 因为需要考虑负负得正。

通过上述分析可以发现，问题既可以被分解为若干子问题，有些子问题的答案又有可能被重复利用， 符合动态规划使用的条件

建立表格 dpMax[i][j] , dpMin[p][q] 
-dpMax[i][j] 表示： 以数组中a[i] 为结尾元素时， 长度为 j+1 的最大乘积子序列的 乘积值 
-dpMin[i][j]表示： 以数组中a[i] 为结尾元素时， 长度为j+1的最小乘积子序列的 乘积值

显然当子序列长度 j=0也就是乘积序列长度为1 时， dpMax[i][j] == dpMin[i][j] = a[i]

这里用 j+1表示长度，而不用j表示的原因是避免数组空间有所浪费， 谁让数组的下标是从0开始的呢。。。没办法
以此为基础， 利用以下递推公式可以逐次求出任意位置的dpMax[i][j] 和 dpMin[i][j]

*/